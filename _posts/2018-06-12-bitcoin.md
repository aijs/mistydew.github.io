---
layout: post
title:  "比特币：一种对等的电子现金系统"
date:   2018-06-12 09:07:06 +0800
author: mistydew
categories: Blockchain
---
<p align="center">
Satoshi Nakamoto<br>
satoshin@gmx.com<br>
www.bitcoin.org
</p>

**概要.** 一个电子现金的纯对等版本将允许在线支付来从一方直接发送到另一方，而不需要通过金融机构。
数字签名提供了部分解决方案，但如果仍需要可信的第三方来防止双重花费，其主要优势将会丢失。
我们提出了使用对等网络的双重花费问题的解决方案。
网络通过把交易时间戳散列到正在运行的基于散列的工作量证明链中，形成不重做工作量证明就无法改变的记录。
最长的链不仅可以作为事件发生顺序的证明，而且可以证明它来自最大的 CPU 能力池。
只要大部分 CPU 能力被不合作攻击该网络的节点控制，它们将产生最长的链并超过攻击者。
网络本身需要最小的结构。
消息以尽力而为的方式广播，节点可以随意离开和重新加入该网络，接受最长的工作量证明链来作为它们离开后发生事件的证明。

## 1. 介绍
互联网上的商务几乎完全依赖作为可信的第三方金融机构来处理电子支付。
尽管系统对大部分交易来说运行良好，但它仍然受到基于信任模型的固有缺点的影响。
完全不可逆的交易事实上是不可能的，因为金融机构无法避免调解纠纷。
调解的成本增加了交易成本，限制了最小特殊交易的规模并切断了小型临时交易的可能性，
而且不可逆服务进行不可逆支付的能力丧失的成本更高。
虽着逆转的可能性，对信任的需求蔓延。
商家必须警惕他们的顾客，纠缠他们以获取更多不需要的信息。
一定比例的欺诈被认为是不可避免的。
这些成本和支付的不确定性能够通过人为的使用纸币来避免，
但是没有机制能够在没有可信任方的情况下通过通讯渠道进行支付。

需要的是一种基于密码学证明而不是信任的电子支付系统，
允许任何两个有意愿的当事方直接与对方交易，而不需要可信任的第三方。
在计算上不可逆转的交易可以保护卖家避免欺诈，并且可以轻松实施例行托管机制来保护买家。
在这篇论文中，我们提出了双重花费问题的解决方案，
使用对等分布式时间戳服务器来生成时间顺序的交易的计算量证明。
只要诚实节点一起控制比任何协作的攻击者节点组更多的 CPU 能力，该系统就是安全的。

## 2. 交易
我们定义电子货币作为数字签名链。
每个所有者把币通过数字签名前一笔交易的哈希和下一个所有者的公钥并把它们添加到币的尾部，转账到下一个所有者。
收款人能够验证签名来验证链的所有权。

![tx](/images/20180612/transaction.jpg)

当然问题是收款人无法验证所有者之一是否双花了币。
普通的解决方案是引入可信的中央权威机构，或铸币厂，检查每笔交易是否双花。
在每笔交易后，货币必须退还给铸币厂以发行新货币，并且只有从铸币厂直接发行的货币才会被信任不会被双花。
该解决方案的问题在于整个货币系统的命运取决于公司运行的铸币厂，每笔交易都必须经过它们，就像银行。

我们需要一种方式让收款人知道前一个所有者没有签署任何更早的交易。
就我们的目的而言，最早的交易是算数的，所以我们不关心之后的双花尝试。
确认交易缺席的唯一方法是知道所有的交易。
在基于铸币厂模型中，铸币厂知道所有的交易并且决定哪笔交易是有效的。
为了在没有可信方的情况下实现这一目的，交易必须公开发布，
并且我们需要让参与者与其收到的订单历史达成一致的系统。
收款人需要每笔交易的时间以及大多数节点都同意该交易是第一个被收到的证明。

## 3. 时间戳服务器
我们建议的这个解决方案以时间戳服务器开始。
时间戳服务器的工作原理是对一组项目进行时间戳的散列并广泛发布散列值，诸如报纸或 Usenet 文章。
时间戳证明数据必须在当时存在，显然是为了散列。
每个时间戳在其散列中都包含前一个时间戳，形成一个链，每个附加上的时间戳都会加强它之前的时间戳。

![timestamp](/images/20180612/timestamp.jpg)

## 4. 工作量证明
为了在对等的基础上实现分布式时间戳服务器，我们需要使用与 Adam Back 的 Hashcash 类似的工作量证明系统，
而不是报纸或 Usenet 文章。
工作量证明涉及扫描散列时的值，例如 SHA-256，从一个 0 位数字开始散列。
所需的平均工作量是指数所需的 0 位数，且能通过执行一个单一散列来验证。

对于我们的时间戳网络，我们通过增加块中的一个随机数来实现工作量证明，
直到找到一个给定区块哈希所需 0 位数的值。
一旦 CPU 花费功夫在使其满足工作量证明上，该块在没有重做工作量的情况下不能改变。
随后区块被连接在后面，改变区块的工作量将包含重做在该块之后全部区块的工作量。

![proofofwork](/images/20180612/proofofwork.jpg)

工作量证明也解决了多数决策中确定代表性的问题。
如果大多数人都是基于一个 IP 地址一个投票，那么任何分配许多 IP 的人都可以破坏它。
工作量证明基本上是一个 CPU 一个投票。
多数决定是由最长的拥有最大工作量证明的链代表。
如果大部分 CPU 能力被诚实节点控制，那么诚实链将会增长的最快并且超过所有竞争链。
为了修改过去的块，一个攻击者必须重做该块和其之后所有块的工作量证明，然后赶上并超过诚实节点的工作。
我们稍后会展示随着后续块的添加，较慢的攻击者追赶上的概率将呈指数级下降。

为了补偿增加的硬件速度以及随着时间的推移对运行的节点的兴趣不断变化，
工作量证明的难度通过一个变化的平均值确定，以每小时的平均块数为平均值。
如果它们产生的过快，难度会增加。

## 5. 网络
这步运行如下网络：

1) 新的交易广播到全部节点。<br>
2) 每个节点收集新的交易到一个区块。<br>
3) 每个节点都为了找一个区块的困难的工作量证明而工作。<br>
4) 当节点找到一个工作量证明时，它会广播该块到全部节点。<br>
5) 如果其内部所有交易都是有效的且没有已经花费的交易，节点就接受该区块。<br>
6) 节点通过在链上使用该区块的散列作为前一个区块的散列创建新区块来表达它们接受了该块。

节点总是认为最长的链是正确的并且继续努力扩展该链。
如果两个节点同时广播不同版本的下一个区块，某些节点可能会首先接收到不同版本的区块。
在这种情况下，它们会在它们首个接收到的区块上工作，但也会保存另一个分支为了防止其变得更长。
当找到下一个工作量证明并且一个分支变得更长时，两个分支的局势将被打破。
在另一个分支上工作的节点将会切换到较长的分支上工作。

新的交易广播不一定需要到达全部节点。
只要它们到达多个节点，不久它们将会进入一个区块。
区块广播也允许丢弃消息。
如果一个节点没有接收到一个区块，它将会在它接收到下一个区块并识别出它错过了一个时请求该区块。

## 6. 激励
按照惯例，区块中第一笔交易是一笔特殊交易，生成属于该区块创建者的新币。
这增加了节点支持网络的激励，并且提供一种初始化时分发币到流通中的方法，因为没有中央权威机构来发行它们。
稳定的郑家一定数量的新币类似于黄金矿工花费资源为了增加黄金到流通中。
在我们的情况中，消耗的是 CPU 时间和电力。

激励也可以用交易费来支付。
如果一笔交易的输出值小于它的输入值，该差值就是交易费，它被添加到包含该交易的区块激励上。
一旦预定数量的币进入循环，激励能够完全转变为交易费并且完全没有通货膨胀。

激励可能有助于鼓励节点保持诚实。
如果是个贪婪的攻击者能够比所有诚实节点聚集更多的 CPU 能力，
他将必须选择通过窃取它的付款或使用它来生成新币来欺诈人们。
他应该会发现按照规则去玩更加有利，这种规则帮助他有比其他人合起来还要多的新币，
而不是破环系统和他拥有的财富值。

## 7. 回收硬盘空间
一旦币中最新的交易埋在足够多的区块中，可以抛弃它之前已经花费的交易以节省硬盘空间。
为了在不破坏区块散列的情况下实现，交易被散列在默尔克树中，只有树根包含在区块散列中。
然后通过除去树枝来压缩旧的区块。
树内部（树枝）哈希不需要存储（在区块中）。

![merkletree](/images/20180612/merkletree.jpg)

一个没有交易的区块头大约 80 个字节。
如果我们假设每 10 分钟产生一个区块，80 字节 * 6 * 24 * 365 = 4.2 兆字节/年。
随着在 2008 年 2GB RAM 的计算机系统销售，且摩尔定于预测目前每年增长 1.2GB，
即使区块头必须在内存中，存储也应该不成问题。

## 8. 简单支付验证
不需要运行完整的网络节点也可以验证支付。用户只需要保留最长工作量证明链的区块头的副本，
他能通过查询网络节点获取，直到他确信他拥有最长的链，并获得默尔克分支，从而把交易连接到加时间戳的区块上。
他不能自行检查交易，但通过连接交易到链上的某个地方，他能够看到网络节点已接受该交易，
并在进一步确认网络接受了该交易后添加到区块上。

![spv](/images/20180612/spv.jpg)

因此，只要诚实节点控制网络，验证就是可靠的，
但如果网络被攻击者控制，则验证会更加脆弱。
虽然网络节点嫩巩固自己验证交易，但只要攻击者继续压制网络，
这种简化的方法就会被攻击者伪造的交易所欺骗。
针对此情况的一种策略是当网络节点侦测到无效块时接受来自网络节点的警报，
提示用户的软件下载完整的区块并提醒交易以确认不一致性。
频繁接收到支付的企业可能仍想要运行它们自己的节点以获得更加独立的安全性和更快的验证。

## 9. 合并与分离价值
虽然有可能单独处理币，但在转账中每一分钱进行一次分离交易将是不切实际的。
为了允许价值被拆分和组合，交易包含多个输入和输出。
通常来自较大金额的前一笔交易的单一输入或联合多个较小金额的输入，
并且最多连个输出：一个用于付款，另一个（如果有）返回找零给发送者。

![inoutput](/images/20180612/inoutput.jpg)

应该指出，交易依赖多个交易，且这些交易依赖更多的交易，在这里不是一个问题。
从不需要提取完整的交易历史的独立副本。

## 10. 隐私
传统的银行模式通过限制访问信息相关方和可信任的第三方来实现一定程度的隐私。
公开公布全部交易的必要性排除了这种方法，
但隐私仍然可以通过打破另一个地方的信息流来维持：通过保持公钥匿名。
公众能够看到某人向某人发送一笔金额，但没有交易与任何人相关联的信息。
这和证券交易所发布的信息类似，其中个别交易的时间和大小（the "tape"）是公开的，但没有告知双方是谁。

![privacy](/images/20180612/privacy.jpg)

作为附加的防火墙，每笔交易都应该使用一个新密钥对，以防它们连接到共同所有者。
对于多输入交易，一些连接仍是不可避免的，这必然会表明它们的输入属于相同的所有者。
风险在于，如果所有者被揭露，则连接可揭示属于该所有者的其他交易。

## 11. 计算
我们认为存在攻击者试图生成比诚实的链更快的替代链的场景。
尽管这个完成了，它也不会使系统面对任意的变化，比如凭空创造价值或不属于攻击者的钱。
节点不会接收无效的交易用作支付，诚实的节点永远不会接收一个包含这种交易的区块。
攻击者只能尝试改变他自己的交易，用来回收他最近花掉的钱。

诚实链和攻击者链之间的竞争可以描述为二项式随机游走。
成功的情况使诚实链延申一个区块，+1领先，而失败的情况是攻击者链延申一个区块，间距-1。

攻击者从给定的赤字中追赶的可能性类似于赌徒破产问题（Gambler's Ruin problem）。
假设一个拥有无限信用的赌徒从赤字开始，并可能进行无限次尝试以达到收支平衡。
我们可以计算出他达到收支平衡的可能性，或攻击者追赶上诚实的链，如下所示：

p = 诚实节点找到下一个块的概率
q = 攻击者找到下一个块的概率
qz = 攻击者将从后面 z 个块追赶上的概率

![math01](/images/20180612/math01.jpg)

根据我们的假设 p > q，随着攻击者追赶上的区块的增加，概率呈指数级减少。
如果他没有提前向前冲刺，赶上的机会会越来越小，因为他落单了。

我们现在考虑在发送人不能改变交易前，一笔新的交易的收款人需要等多久。
我们假设发送人是一个想让收款人详细他支付了一会了的攻击者，在过了一段时间后钱又回到他自己。
当发生这种情况时，这个收款人会收到警报，但发送者希望这个警报已经晚了。

收款人在签名前不久生成了一个新的密钥对并把公钥给了发送者。
这可以防止发送者提前准备好区块链，持续在该链上工作直到他有幸前进的足够远。
一旦交易被发送，不诚实的发送者开始在一条包含他替代版的交易的平行链上秘密工作。

收款人等到交易添加到区块上且 z 个块被链接在该块后面。
他不知道攻击者进展的具体数量，但假设诚实的区块花费了每个区块被挖出的平均时间，
攻击者的潜在进度将是具有预期值的泊松分布（Poisson distribution）：

![math02](/images/20180612/math02.jpg)

为了获得攻击者现在可能仍在追赶的概率，
我们将泊松密度乘以他从那个点赶上额概率所取得的进步量：

![math03](/images/20180612/math03.jpg)

重新排列以避免对分布的无穷尾数求和...

![math04](/images/20180612/math04.jpg)

转换为 C 代码...
{% highlight C %}
#include <math.h>

double AttackerSuccessProbability(double q, int z)
{
	double p = 1.0 - q;
	double lambda = z * (q / p);
	double sum = 1.0;
	int i, k;
	for (k = 0; k <= z; k++)
	{
		double poisson = exp(-lambda);
		for (i = 1; i <= k; i++)
			poisson *= lambda / i;
		sum -= poisson * (1 - pow(q / p, z - k));
	}
	return sum;
}
{% endhighlight %}

部分运行结果，我们可以看到概率随 z 呈指数下降。
{% highlight shell %}
q=0.1
z=0    P=1.0000000
z=1    P=0.2045873
z=2    P=0.0509779
z=3    P=0.0131722
z=4    P=0.0034552
z=5    P=0.0009137
z=6    P=0.0002428
z=7    P=0.0000647
z=8    P=0.0000173
z=9    P=0.0000046
z=10   P=0.0000012

q=0.3
z=0    P=1.0000000
z=5    P=0.1773523
z=10   P=0.0416605
z=15   P=0.0101008
z=20   P=0.0024804
z=25   P=0.0006132
z=30   P=0.0001522
z=35   P=0.0000379
z=40   P=0.0000095
z=45   P=0.0000024
z=50   P=0.0000006
{% endhighlight %}

P 小于 0.1% 解决...

{% highlight shell %}
P < 0.001
q=0.10   z=5
q=0.15   z=8
q=0.20   z=11
q=0.25   z=15
q=0.30   z=24
q=0.35   z=41
q=0.40   z=89
q=0.45   z=340
{% endhighlight %}

## 12. 结论
我们提出了不依赖信任的电子交易系统。
我们从普通的数字签名框架开始制作币，它提供所属权的强大的控制力，但是没有防止双重花费的方法是不完整的。
为了解决该问题，我们提出了使用工作量证明的对等网络来记录公共交易历史，
如果诚实节点控制了 CPU 的主要能力，攻击者在计算上很快就会变得不切实际。
该网络是非结构化简单健壮的。
节点们只需很少的协作即可完成全部工作。
它们不需要被识别，因为消息不会被路由到任何特定地方，只需要尽力而为地传递。
节点能够随意离开和重新加入网络，接受工作量证明链作为它们离开后发生事件的证明。
它们使用其 CPU 能力投票，表示它们通过接受有效块来扩展工作量，通过拒绝无效块来拒绝在其上面工作。
任何需要的规则和激励都可以通过这种共识机制强制执行。

## 感想
在接触区块链后再回来看看白皮书，发现有些部分豁然开朗。<br>
从头串到尾，这就是主线。

## 参照
* [Bitcoin: A Peer-to-Peer Electronic Cash System](https://bitcoin.org/bitcoin.pdf)
* [...](https://github.com/mistydew/blockchain)
